import os
import argparse
import pickle

import numpy as np
from scipy.special import gamma, digamma

results_dir = os.getcwd() + "/results/"


def save_obj(obj, title):
    with open(title + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)

def load_obj(title):
    with open(title, 'rb') as f:
        return pickle.load(f)


class SBL_BB():
    """
    DESCRIPTION: Beta-Bernoulli Bayesian Sequential Learning Agent
        * Agent parses a binary sequence previously generated by HHMM
        * She updates her conjugate Beta-Bernoulli posterior with new evidence
        * She calculates different surprise measures as the come in
    INPUT: Binary Sequence and Exponentially Weighted forgetting parameter
    OUTPUT: Predictive surprisal, Bayesian surprisal, Confidence-corrected surprisal
    [t, o_t, s_t, Prediction_Surprise, Bayesian_Surprise, Confidence_Corrected_Surprise]
    """
    def __init__(self, seq, hidden, tau):
        # Initialize SBL-learned sequence and exponential forgetting parameter
        self.sequence = seq
        self.hidden = hidden
        self.T = len(seq)
        self.tau = tau

        self.no_obs = 2

        # AP: Generate T-dim vector indicating no-alternation from t-1 to t
        self.repetition = np.zeros(self.T)
        for t in range(1, self.T):
            if self.sequence[t] == self.sequence[t-1]:
                self.repetition[t] = 1

        # TP: Generate T-dim vectors indicating transition from state i
        self.transitions = np.zeros((self.T, self.no_obs))
        for t in range(1, self.T):
            self.transitions[t, 0] = (self.sequence[t-1] == 0)
            self.transitions[t, 1] = 1 - self.transitions[t, 0]

        # Generate one T matrix with all discounting values
        self.exp_forgetting = np.exp(-self.tau*np.arange(self.T)[::-1])

    def update_posterior(self, t, type):
        exp_weighting = self.exp_forgetting[-t:]

        if type == "SP":
            self.alpha = 1 + np.dot(exp_weighting, self.sequence[:t])
            self.beta = 1 + np.dot(exp_weighting, 1-self.sequence[:t])
        elif type == "AP":
            if t == 1:
                print("Can't update posterior with only one observation - need two!")
                self.alpha = 1
                self.beta = 1
            else:
                self.alpha = 1 + np.dot(exp_weighting[1:], self.repetition[1:t])
                self.beta = 1 + np.dot(exp_weighting[1:], 1-self.repetition[1:t])
        elif type == "TP":
            # print(self.sequence[:t], self.transition_from_0[:t], self.transition_from_1[:t])
            self.alpha = np.empty(self.no_obs)
            self.beta = np.empty(self.no_obs)
            if t == 1:
                print("Can't update posterior with only one observation - need two!")
                self.alpha = np.ones(self.no_obs)
                self.beta = np.ones(self.no_obs)
            else:
                for i in range(self.no_obs):
                    self.alpha[i] = 1 + np.dot(exp_weighting[1:], self.sequence[1:t]*self.transitions[1:t, i])
                    self.beta[i] = 1 + np.dot(exp_weighting[1:], (1 - self.sequence[1:t])*self.transitions[1:t, i])

    def compute_surprisal(self, type):
        print("{}: Computing different surprisal measures for all {} timesteps.".format(type, self.T))
        results = []

        for t in range(2, self.T):
            # Loop over the full sequence and compute surprisal iteratively
            self.update_posterior(t-1, type)
            PS_temp = self.predictive_surprisal(t, type)
            BS_temp = self.bayesian_surprisal(t, type)
            CS_temp = self.corrected_surprisal(t, type)
            temp = [t, self.sequence[t], self.hidden[t], PS_temp, BS_temp, CS_temp]
            try:
                distr_params = [item for sublist in [self.alpha.tolist(), self.beta.tolist()] for item in sublist]
            except:
                distr_params = [self.alpha, self.beta]
            results.append(temp + distr_params)
        print("{}: Done computing surprisal measures for all {} timesteps.".format(type, self.T))
        return np.asarray(results)

    def predictive_surprisal(self, t, type):
        if type == "SP":
            PS = -np.log(((self.alpha/(self.alpha + self.beta))**self.sequence[t]) \
                         *((1 - self.alpha/(self.alpha + self.beta))**(1-self.sequence[t])))
        elif type == "AP":
            PS = -np.log(((self.alpha/(self.alpha + self.beta))**self.repetition[t]) \
                         *((1 - self.alpha/(self.alpha + self.beta))**(1-self.repetition[t])))
        elif type == "TP":
            PS = 0
            for i in range(self.transitions.shape[1]):
                PS += -self.transitions[t, i]*\
                       np.log((self.alpha[i]/(self.alpha[i] + self.beta[i]))**self.sequence[t]*\
                              (1 - self.alpha[i]/(self.alpha[i] + self.beta[i]))**(1 - self.sequence[t]))
        return PS

    def bayesian_surprisal(self, t, type):
        if type == "SP":
            BS = np.log(gamma(self.alpha + self.beta)/(gamma(self.alpha) * gamma(self.beta))) \
                 - np.log(gamma(self.alpha + self.beta + 1)/(gamma(self.alpha + self.sequence[t]) * gamma(self.beta + 1 - self.sequence[t]))) \
                 - self.sequence[t]*digamma(self.alpha) + (self.sequence[t] - 1)*digamma(self.beta) + digamma(self.alpha + self.beta)
        elif type == "AP":
            BS = np.log(gamma(self.alpha + self.beta)/(gamma(self.alpha) * gamma(self.beta))) \
                 - np.log(gamma(self.alpha + self.beta + 1)/(gamma(self.alpha + self.repetition[t]) * gamma(self.beta + 1 - self.repetition[t]))) \
                 - self.repetition[t]*digamma(self.alpha) + (self.repetition[t] - 1)*digamma(self.beta) + digamma(self.alpha + self.beta)
        elif type == "TP":
            BS = 0
            for i in range(self.transitions.shape[1]):
                BS += self.transitions[t, i]*\
                      (np.log(gamma(self.alpha[i] + self.beta[i])/(gamma(self.alpha[i]) * gamma(self.beta[i])))\
                       - np.log(gamma(self.alpha[i] + self.beta[i] + 1)/(gamma(self.alpha[i] + self.sequence[t]) * gamma(self.beta[i] + 1 - self.sequence[t]))) \
                       - self.sequence[t]*digamma(self.alpha[i]) + (self.sequence[t] - 1)*digamma(self.beta[i]) + digamma(self.alpha[i] + self.beta[i]))
        return BS

    def corrected_surprisal(self, t, type):
        if type == "SP":
            CS = np.log(gamma(self.alpha + self.beta)/(gamma(self.alpha) * gamma(self.beta))) - np.log(2) \
                 + (self.alpha - 1 - self.sequence[t])*digamma(self.alpha) \
                 + (self.beta - 2 + self.sequence[t])*digamma(self.beta) \
                 + (3 - self.alpha - self.beta)*digamma(self.alpha + self.beta)
        elif type == "AP":
            CS = np.log(gamma(self.alpha + self.beta)/(gamma(self.alpha) * gamma(self.beta))) - np.log(2) \
                 + (self.alpha - 1 - self.repetition[t])*digamma(self.alpha) \
                 + (self.beta - 2 + self.repetition[t])*digamma(self.beta) \
                 + (3 - self.alpha - self.beta)*digamma(self.alpha + self.beta)
        elif type == "TP":
            CS = 0
            for i in range(self.transitions.shape[1]):
                CS += self.transitions[t, i]*\
                      (np.log(gamma(self.alpha[i] + self.beta[i])/(gamma(self.alpha[i]) * gamma(self.beta[i])))\
                       - np.log(2) + (self.alpha[i] - 1 - self.sequence[t])*digamma(self.alpha[i])\
                       + (self.beta[i] - 2 - self.sequence[t])*digamma(self.beta[i]) +(3 - self.alpha[i] - self.beta[i])*digamma(self.alpha[i] + self.beta[i]))
        return CS


def main(seq, hidden, tau, model,
         prob_regime_init, prob_obs_init, prob_obs_change, prob_regime_change,
         save_results=False, title="temp"):
    # II: Compute Surprisal for all time steps for Stimulus Prob BB Model
    BB_SBL_temp = SBL_BB(seq, hidden, tau)
    results = BB_SBL_temp.compute_surprisal(model)

    time = results[:,0]
    sequence = results[:, 1]
    hidden = results[:, 2]
    PS = results[:, 2]
    BS = results[:, 3]
    CS = results[:, 4]

    results_formatted = {"time": time,
                         "sequence": sequence,
                         "hidden": hidden,
                         "predictive_surprise": PS,
                         "bayesian_surprise": BS,
                         "confidence_corrected_surprise":CS,
                         "prob_regime_init": prob_regime_init,
                         "prob_obs_init": prob_obs_init,
                         "prob_obs_change": prob_obs_change,
                         "prob_regime_change": prob_regime_change}

    if save_results:
        save_obj(results_formatted, results_dir + title)


def test_agent(seq, hidden, tau, model):
    # Test IIa: Initialize SBL (seq, forgetting param), update posterior (t=3)
    BB_SBL_temp = SBL_BB(seq, hidden, tau=0.)
    BB_SBL_temp.update_posterior(2, model)
    print("{}: Beta-Distribution after 2 timestep: alpha = {}, beta = {}".format(model, BB_SBL_temp.alpha, BB_SBL_temp.beta))
    print("---------------------------------------------")

    # Test IIb: Compute Surprisal once (SP, t=3)
    print("{}: Predictive Surprisal at t=3: {}".format(model, BB_SBL_temp.predictive_surprisal(3, model)))
    print("{}: Bayesian Surprisal at t=3: {}".format(model, BB_SBL_temp.bayesian_surprisal(3, model)))
    print("{}: Confidence-Corrected Surprisal at t=3: {}".format(model, BB_SBL_temp.corrected_surprisal(3, model)))
    print("---------------------------------------------")

    # Test IIc: Compute Surprisal for all time steps for Stimulus Prob BB Model
    results = BB_SBL_temp.compute_surprisal(model)
    print("---------------------------------------------")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-file', '--sample_file', action="store",
                        default="temporary_sample_title", type=str,
                        help='Title of file in which sequence in stored')
    parser.add_argument('-tau', '--forget_param', action="store",
                        default=0., type=float,
                        help='Exponentially weighting parameter for memory/posterior updating')
    parser.add_argument('-model', '--model', action="store", default="SP",
                        type=str,
                        help='Beta-Bernoulli Probability Model (SP, AP, TP)')
    parser.add_argument('-T', '--test', action="store_true", help='Run tests.')
    parser.add_argument('-S', '--save', action="store_true", help='Save results to array.')

    args = parser.parse_args()

    sample = load_obj(results_dir + args.sample_file + ".pkl")

    seq = sample["sample_output"][:, 1]
    hidden = sample["sample_output"][:, 0]

    prob_regime_init = sample["prob_regime_init"]
    prob_obs_init = sample["prob_obs_init"]
    prob_obs_change = sample["prob_obs_change"]
    prob_regime_change = sample["prob_regime_change"]

    tau = args.forget_param
    model = args.model

    run_test = args.test
    save_results = args.save

    if run_test:
        print("Started running basic tests.")
        test_agent(seq, hidden, tau, model)

    else:
        main(seq, hidden, tau, model,
             prob_regime_init, prob_obs_init, prob_obs_change,
             prob_regime_change,
             save_results, title="BB_" + model + "_" + args.sample_file)

    """
    python mmn_sbl.py -model SP
    """
