import os
import time
import argparse
import pickle

import numpy as np
from scipy.stats import binom, norm
from sklearn.metrics import mutual_info_score

results_dir = os.getcwd() + "/results/"


def save_obj(obj, title):
    with open(title + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)

def load_obj(title):
    with open(title, 'rb') as f:
        return pickle.load(f)


class SBL_GRW():
    """
    DESCRIPTION: Gaussian Random Walk Bayesian Sequential Learning Agent
        * Agent parses a binary sequence previously generated by HHMM
        * She updates her intractable posterior with new evidence
        * She calculates different surprise measures as the come in
    INPUT: Binary Sequence and Exponentially Weighted forgetting parameter
    OUTPUT: Predictive surprisal, Bayesian surprisal, Confidence-corrected surprisal
    [t, o_t, s_t, Prediction_Surprise, Bayesian_Surprise, Confidence_Corrected_Surprise]
    """
    def __init__(self, seq, hidden, sigma, s_min, s_max, s_res):
        # Initialize SBL-learned sequence and exponential forgetting parameter
        self.sequence = seq
        self.hidden = hidden
        self.T = len(seq)

        self.no_obs = 2

        # Define discretized space of latent variable for numerical integration
        self.sigma = sigma
        self.s_res = s_res
        self.s_space = np.linspace(s_min,s_max,s_res)

        # AP: Generate T-dim vector indicating no-alternation from t-1 to t
        self.repetition = np.zeros(self.T)
        for t in range(1, self.T):
            if self.sequence[t] == self.sequence[t - 1]:
                self.repetition[t] = 1
        self.repetition = self.repetition.astype(int)

        self.posterior = np.repeat(1./self.s_res, self.s_res)
        self.posterior_naive = np.zeros(self.s_res)

        self.P = np.zeros([self.no_obs, self.s_res, self.s_res, self.T])
        self.P_naive = np.zeros([self.no_obs, self.s_res, self.s_res])

        i_ax = np.repeat(np.linspace(s_min, s_max, self.s_res),
                         self.s_res)#-5, -5,..., -5, -4.8, -4.8,....
        j_ax = np.tile(np.linspace(-5, 5, 70), 70) #-5, -4.8,..., 5,..., -5

        self.normal_lookup = norm.pdf(i_ax, j_ax, self.sigma).reshape((self.s_res, self.s_res))
        self.bernoulli_lookup = binom.pmf(1, 1, 1 / (1 + np.exp(-i_ax)))

    def update_posterior(self, t, type):
        if t == 0:
            for i in range(0, self.s_res):
                for j in range(0, self.s_res):
                    self.P[0, i, j, t] = (1 - self.bernoulli_lookup[i]) \
                                       * self.normal_lookup[i, j] * self.posterior[j]
                    self.P[1, i, j, t] = self.bernoulli_lookup[i] \
                                       * self.normal_lookup[i, j] * self.posterior[j]
                    self.P_naive[0, i, j] = self.P[0, i, j, t]
                    self.P_naive[1, i, j] = self.P[1, i, j, t]
        else:
            # calculate joint distribution for each entry in matrix
            # [p(o_t,s_t,s_t-1|o_t-1) = Bern(o_t;l(1_t)) * N(s_t;s_t-1;sigma) * p(s_t)]
            # k: all possible observations; i: distribution for s_t conditioned on j: values of s_t-1
            for i in range(0, self.s_res):
                for j in range(0, self.s_res):
                    self.P[0, i, j, t] = (1 - self.bernoulli_lookup[i]) \
                                         * self.normal_lookup[i, j] * self.posterior[j]
                    self.P[1, i, j, t] = self.bernoulli_lookup[i] \
                                         * self.normal_lookup[i, j] * self.posterior[j]
        # evaluate unobserved stimulus distribution
        if type == "SP":
            P_ij = self.P[self.sequence[t], :, :, t]
            P_ij_naive = self.P_naive[self.sequence[t], :, :]
        elif type == "AP":
            P_ij = self.P[self.repetition[t], :, :, t]
            P_ij_naive = self.P_naive[self.repetition[t], :, :]
        else:
            print("Choose a valid type!")

        # integration by summation
        P_sum_over_j = np.sum(P_ij, 1)
        P_sum_over_j_naive = np.sum(P_ij_naive, 1)

        P_sum_over_ij = np.sum(P_sum_over_j)
        P_sum_over_ij_naive = np.sum(P_sum_over_j_naive)

        P_sum_over_kij = np.sum(np.sum(np.sum(self.P[:, :, :, t], 0), 0), 0)

        # evaluate posterior
        posterior_lag = self.posterior[:]
        self.posterior = P_sum_over_j / P_sum_over_ij
        self.posterior_naive = P_sum_over_j_naive / P_sum_over_ij_naive
        self.predictive = P_sum_over_ij / P_sum_over_kij

        return posterior_lag


    def compute_surprisal(self, type):
        print("{}: Computing different surprisal measures for all {} timesteps.".format(type, self.T))

        results = []

        self.update_posterior(1, type)

        for t in range(2, self.T):
            # Loop over the full sequence and compute surprisal iteratively
            posterior_lag = self.update_posterior(t, type)
            PS_temp = self.predictive_surprisal()
            BS_temp = self.bayesian_surprisal(posterior_lag)
            CS_temp = self.corrected_surprisal(posterior_lag)
            temp = [t, self.sequence[t], self.hidden[t], PS_temp, BS_temp, CS_temp]
            results.append(temp)
        print("{}: Done computing surprisal measures for all {} timesteps.".format(type, self.T))
        return np.asarray(results)

    def predictive_surprisal(self):
        return -np.log(self.predictive)

    def bayesian_surprisal(self, posterior_lag):
        BS = mutual_info_score(posterior_lag, self.posterior)
        return BS

    def corrected_surprisal(self, posterior_lag):
        CS = mutual_info_score(posterior_lag, self.posterior_naive)
        return CS



def main(seq, hidden, sigma, s_min, s_max, s_res, model,
         prob_regime_init, prob_obs_init, prob_obs_change,
         prob_regime_change, save_results=False, title="temp"):
    # Compute Surprisal for all time steps for Stimulus Prob BB Model
    BB_SBL_temp = SBL_GRW(seq, hidden, sigma, s_min, s_max, s_res)
    results = BB_SBL_temp.compute_surprisal(model)

    time = results[:,0]
    sequence = results[:, 1]
    hidden = results[:, 2]
    PS = results[:, 2]
    BS = results[:, 3]
    CS = results[:, 4]

    results_formatted = {"time": time,
                         "sequence": sequence,
                         "hidden": hidden,
                         "predictive_surprise": PS,
                         "bayesian_surprise": BS,
                         "confidence_corrected_surprise":CS,
                         "prob_regime_init": prob_regime_init,
                         "prob_obs_init": prob_obs_init,
                         "prob_obs_change": prob_obs_change,
                         "prob_regime_change": prob_regime_change}

    if save_results:
        save_obj(results_formatted, results_dir + title)



def test_agent(seq, hidden, sigma, s_min, s_max, s_res, model):
    # Test IIa: Initialize SBL (seq, forgetting param), update posterior (t=3)
    GRW_SBL_temp = SBL_GRW(seq, hidden, sigma, s_min, s_max, s_res)
    GRW_SBL_temp.update_posterior(2, model)
    print("---------------------------------------------")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-file', '--sample_file', action="store",
                        default="temporary_sample_title", type=str,
                        help='Title of file in which sequence in stored')
    parser.add_argument('-sigma', '--sigma', action="store", default=2.5, type=float,
                        help='Step Size of GRW in latent space')
    parser.add_argument('-s_min', '--space_min', action="store", default=-5, type=float,
                        help='Min of Discretized Latent Space')
    parser.add_argument('-s_max', '--space_max', action="store", default=5, type=float,
                        help='Max of Discretized Latent Space')
    parser.add_argument('-s_res', '--space_res', action="store", default=70, type=float,
                        help='Bins/Values of Discretized Latent Space')

    parser.add_argument('-model', '--model', action="store", default="SP", type=str,
                        help='Gaussian Random Walk Probability Model (SP, AP, TP)')
    parser.add_argument('-T', '--test', action="store_true", help='Run tests.')
    parser.add_argument('-S', '--save', action="store_true", help='Save results to array.')

    args = parser.parse_args()

    sample = load_obj(results_dir + args.sample_file + ".pkl")

    seq = sample["sample_output"][:, 2]
    hidden = sample["sample_output"][:, 1]

    prob_regime_init = sample["prob_regime_init"]
    prob_obs_init = sample["prob_obs_init"]
    prob_obs_change = sample["prob_obs_change"]
    prob_regime_change = sample["prob_regime_change"]

    sigma = args.sigma
    s_min = args.space_min
    s_max = args.space_max
    s_res = args.space_res
    model = args.model

    run_test = args.test
    save_results = args.save

    if run_test:
        print("Started running basic tests.")
        test_agent(seq, hidden, sigma, s_min, s_max, s_res, model)

    else:
        start = time.time()
        main(seq, hidden, sigma, s_min, s_max, s_res, model,
             prob_regime_init, prob_obs_init, prob_obs_change,
             prob_regime_change, save_results,
             title="GRW_" + model + "_" + args.sample_file)
        print("Done after {} secs".format(time.time() - start))
