import os
import argparse
import numpy as np
import math
from hmmlearn import hmm
from utils.helpers import *


def hmm_action_selection(model, state_seq, sample=False):
    """
    Input: HMM model and a state_seq
    Output: Computes p(x_t|x_t-1,...,x_0)
    TODO: Make option to greedly select next action!
    """
    valid_successors, moves = get_valid_succesor(wm, state_seq[-1])
    coded_successors = string_to_code(valid_successors, observations)[0]
    current_v_state, lengths = string_to_code([state_seq], observations)

    # One HMM State Transition
    logprob, posteriors = model.score_samples(current_v_state, lengths)
    cond_distr = np.matmul(model.emissionprob_.T,
                           np.matmul(model.transmat_.T, posteriors.T))

    full_distr_next_v_state = cond_distr[:, -1].ravel()
    distr_next_v_state = full_distr_next_v_state[coded_successors].ravel()/sum(full_distr_next_v_state[coded_successors]).ravel()
    n_valid_v_states = len(distr_next_v_state)

    # Sample or argmax
    if sample:
        next_move = np.random.choice(n_valid_v_states, 1, p=distr_next_v_state)[0]
    else:
        next_move = np.argmax(distr_next_v_state)

    # next_v_state = valid_successors[0][next_move]
    return next_move, full_distr_next_v_state


    startprob, transmat, emissionprob = init_hmm(no_obs=3, n_states=2)
    model = hmm_posterior(seq.reshape(1, -1).T,
                          startprob, transmat, emissionprob,
                          get_ic=False)


class SBL_HMM():
    """
    DESCRIPTION: Hidden Markov Model Bayesian Sequential Learning Agent
        * Agent parses a binary sequence previously generated by HHMM
        * She updates her HMM posterior with new evidence
        * She calculates different surprise measures as the come in
    INPUT: Binary Sequence and Exponentially Weighted forgetting parameter
    OUTPUT: Predictive surprisal, Bayesian surprisal, Confidence-corrected surprisal
    [t, o_t, s_t, Prediction_Surprise, Bayesian_Surprise, Confidence_Corrected_Surprise]
    """
    def __init__(self, seq, hidden, n_states, model_type="SP", verbose=False):
        # Initialize SBL-learned sequence and exponential forgetting parameter
        self.sequence = seq.astype(int)
        self.hidden = hidden
        self.T = len(seq)

        self.type = model_type
        self.n_states = n_states
        self.verbose = verbose

        self.no_obs = np.unique(seq).shape[0]
        self.stim_ind = np.zeros((self.T, self.no_obs))

        # Construct matrix where col represents binary ind of specific stim at t
        for t in range(self.T):
            self.stim_ind[t, self.sequence[t]] = 1

        # AP: Generate T-dim vector indicating no-alternation from t-1 to t
        self.repetition = np.zeros(self.T)
        for t in range(1, self.T):
            if self.sequence[t] == self.sequence[t-1]:
                self.repetition[t] = 1

        # TP: Generate T-dim vectors indicating transition from state i
        self.transitions = np.zeros((self.T, self.no_obs))
        for t in range(1, self.T):
            self.transitions[t, 0] = (self.sequence[t-1] == 0)
            self.transitions[t, 1] = (self.sequence[t-1] == 1)
            self.transitions[t, 2] = (self.sequence[t-1] == 2)

        if self.type == "SP":
            self.posterior = np.ones(self.no_obs)/self.no_obs
        elif self.type == "AP":
            self.posterior = np.ones(2)/2
        elif self.type == "TP":
            self.posterior = np.ones((self.no_obs, self.no_obs))/self.no_obs
        else:
            raise "Provide right model type (SP, AP, TP)"

    def init_hmm(self):
        """
        Input: number of desired hidden states for HMM model
        Output: Uniformly initialized matrices for HMM training
        """
        startprob = np.repeat(1./self.n_states, self.n_states)
        transmat = np.repeat([startprob], self.n_states, axis=0)
        if self.type == "SP":
            temp = np.repeat(1./self.no_obs, self.no_obs)
        elif self.type == "AP":
            temp = np.repeat(1./2, 2)
        emissionprob = np.repeat([temp], self.n_states, axis=0)

        return startprob, transmat, emissionprob

    def calc_all_posteriors(self):
        """
        Input: Unique state id transformed data, length per ep trace and HMM inits
        Output: The trained HMM model with all attributes
        - Option: If desired get AIC and BIC for model as well
        """
        startprob, transmat, emissionprob = self.init_hmm()
        # Uniform Initialization
        model = hmm.MultinomialHMM(n_components=self.n_states)
        model.startprob = startprob
        model.transmat = transmat
        model.emissionprob = emissionprob

        if self.type == "SP":
            temp = self.sequence[:self.T+1].reshape(1, -1).T
        elif self.type == "AP":
            temp = self.repetition[:self.T+1].reshape(1, -1).T.astype(int)

        self.model = model.fit(temp)
        logprob, posteriors = model.score_samples(temp)
        return posteriors

    def posterior_predictive(self, posterior):
        return np.matmul(self.model.emissionprob_.T,
                         np.matmul(self.model.transmat_.T, posterior.T))

    def naive_posterior(self, posterior):
        return self.posterior_predictive(posterior)/self.posterior_predictive(posterior).sum(axis=0)

    def predictive_surprisal(self, posterior, ind):
        return -np.log(self.posterior_predictive(posterior)[ind])

    def bayesian_surprisal(self, posterior_old, posterior):
        return kl_general(posterior_old, posterior)

    def corrected_surprisal(self, posterior):
        # kl_general(self.naive_posterior(posterior), posterior)
        return 0

    def compute_surprisal(self, max_T, verbose_surprisal=False):
        print("{}: Computing different surprisal measures for {} timesteps.".format(self.type, max_T))
        results = []

        hmm_init_posterior = np.repeat(1./self.n_states, self.n_states)
        hmm_posteriors = self.calc_all_posteriors()

        for t in range(max_T):
            # Loop over the full sequence and compute surprisal iteratively
            self.t = t
            if t == 0:
                posterior_old = hmm_init_posterior
            else:
                posterior_old = hmm_posteriors[t-1]

            posterior = hmm_posteriors[t]

            if self.type == "SP":
                ind = int(self.sequence[self.t])
            elif self.type == "AP":
                ind = int(self.repetition[self.t])
            elif self.type == "TP":
                # from and to stimulus transition
                ind = (np.argmax(self.transitions[self.t, :]), np.argmax(self.stim_ind[self.t, :]))
            else:
                raise "Provide right model type (SP, AP, TP)"

            PS_temp = self.predictive_surprisal(posterior, ind)
            BS_temp = self.bayesian_surprisal(posterior_old, posterior)
            CS_temp = self.corrected_surprisal(posterior)

            if verbose_surprisal:
                print("{} - t={}: PS={}, BS={}, CS={}".format(self.type, t+1, round(PS_temp, 4),  round(BS_temp, 4), round(CS_temp, 4)))

            temp = [t, self.sequence[t], self.hidden[t], PS_temp, BS_temp, CS_temp]
            distr_params = list(posterior.reshape(1, -1)[0])
            results.append(temp + distr_params)
        print("{}: Done computing surprisal measures for all {} timesteps.".format(self.type, self.T))
        return np.asarray(results)


def main(seq, hidden, n_states, model_type,
         prob_regime_init, prob_obs_init, prob_obs_change, prob_regime_change,
         save_results=False, title="temp", verbose=False):
    # II: Compute Surprisal for all time steps for Stimulus Prob CatDir Model
    HMM_SBL_temp = SBL_HMM(seq, hidden, n_states, model_type)
    results = HMM_SBL_temp.compute_surprisal(max_T=HMM_SBL_temp.T)

    time = results[:, 0]
    sequence = results[:, 1]
    hidden = results[:, 2]
    PS = results[:, 2]
    BS = results[:, 3]
    CS = results[:, 4]

    results_formatted = {"time": time,
                         "sequence": sequence,
                         "hidden": hidden,
                         "predictive_surprise": PS,
                         "bayesian_surprise": BS,
                         "confidence_corrected_surprise": CS,
                         "prob_regime_init": prob_regime_init,
                         "prob_obs_init": prob_obs_init,
                         "prob_obs_change": prob_obs_change,
                         "prob_regime_change": prob_regime_change}

    if save_results:
        save_obj(results_formatted, results_dir + title)
        print("Saved in File: {}".format(results_dir + title))


def test_agent(seq, hidden, n_states, model_type, verbose=False):
    # Test IIa: Initialize SBL (seq, forgetting param), update posterior (t=3)
    HMM_SBL_temp = SBL_HMM(seq, hidden, n_states, model_type=model_type)
    # Test IIb: Compute Surprisal once (SP, t=3)
    HMM_SBL_temp.compute_surprisal(max_T=3, verbose_surprisal=True)
    # print("---------------------------------------------")
    # # Test IIc: Compute Surprisal for all time steps for Stimulus Prob BB Model
    # results = CD_SBL_temp.compute_surprisal(max_T=CD_SBL_temp.T)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-file', '--sample_file', action="store",
                        default="temporary_sample_title", type=str,
                        help='Title of file in which sequence in stored')
    parser.add_argument('-states', '--n_states', action="store",
                        default=2, type=int,
                        help='Number of Hidden States in HMM')
    parser.add_argument('-model', '--model', action="store", default="SP",
                        type=str,
                        help='Categorical Dirichlet Probability Model (SP, AP, TP)')
    parser.add_argument('-pkl_in', '--pickle', action="store_true", help='Load matlab sequence file.')
    parser.add_argument('-T', '--test', action="store_true", help='Run tests.')
    parser.add_argument('-S', '--save', action="store_true", help='Save results to array.')
    parser.add_argument('-v', '--verbose',
                        action="store_true",
                        default=False,
						help='Get status printed out')

    args = parser.parse_args()

    if args.pickle:
        sample = load_obj(results_dir + args.sample_file + ".pkl")
    else:
        sample = load_obj(results_dir + args.sample_file + ".mat")

    seq = sample["sample_output"][:, 2]
    hidden = sample["sample_output"][:, 1]

    prob_regime_init = sample["prob_regime_init"]
    prob_obs_init = sample["prob_obs_init"]
    prob_obs_change = sample["prob_obs_change"]
    prob_regime_change = sample["prob_regime_change"]

    n_states = args.n_states
    model = args.model

    run_test = args.test
    save_results = args.save
    verbose = args.verbose

    if run_test:
        print("Started running basic tests.")
        test_agent(seq, hidden, n_states, model, verbose)

    else:
        main(seq, hidden, n_states, model,
             prob_regime_init, prob_obs_init, prob_obs_change,
             prob_regime_change,
             save_results, title="HMM_" + model + "_" + args.sample_file,
             verbose=False)

    """
    How to run:
        pythonw seq_gen.py -t S1_800 -obs_change 0.75 0.15 0.85 0.25 0.5 0.75 0.25 0.5 -order 2 -matlab -seq 500
        pythonw sbl_hmm.py -file S1_800 -S -model SP
    """
