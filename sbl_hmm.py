import os
import argparse
import numpy as np
import math
from hmmlearn import hmm
from helpers import *


def hmm_action_selection(model, state_seq, sample=False):
    """
    Input: HMM model and a state_seq
    Output: Computes p(x_t|x_t-1,...,x_0)
    TODO: Make option to greedly select next action!
    """
    valid_successors, moves = get_valid_succesor(wm, state_seq[-1])
    coded_successors = string_to_code(valid_successors, observations)[0]
    current_v_state, lengths = string_to_code([state_seq], observations)

    # One HMM State Transition
    logprob, posteriors = model.score_samples(current_v_state, lengths)
    cond_distr = np.matmul(model.emissionprob_.T,
                           np.matmul(model.transmat_.T, posteriors.T))

    full_distr_next_v_state = cond_distr[:, -1].ravel()
    distr_next_v_state = full_distr_next_v_state[coded_successors].ravel()/sum(full_distr_next_v_state[coded_successors]).ravel()
    n_valid_v_states = len(distr_next_v_state)

    # Sample or argmax
    if sample:
        next_move = np.random.choice(n_valid_v_states, 1, p=distr_next_v_state)[0]
    else:
        next_move = np.argmax(distr_next_v_state)

    # next_v_state = valid_successors[0][next_move]
    return next_move, full_distr_next_v_state


    startprob, transmat, emissionprob = init_hmm(no_obs=3, n_states=2)
    model = hmm_posterior(seq.reshape(1, -1).T,
                          startprob, transmat, emissionprob,
                          get_ic=False)

class SBL_HMM():
    """
    DESCRIPTION: Categorical Dirichlet Bayesian Sequential Learning Agent
        * Agent parses a binary sequence previously generated by HHMM
        * She updates her conjugate Cat-Dirichlet posterior with new evidence
        * She calculates different surprise measures as the come in
    INPUT: Binary Sequence and Exponentially Weighted forgetting parameter
    OUTPUT: Predictive surprisal, Bayesian surprisal, Confidence-corrected surprisal
    [t, o_t, s_t, Prediction_Surprise, Bayesian_Surprise, Confidence_Corrected_Surprise]
    """
    def __init__(self, seq, hidden, tau, n_states=2, verbose=False):
        # Initialize SBL-learned sequence and exponential forgetting parameter
        self.sequence = seq.astype(int)
        self.hidden = hidden
        self.T = len(seq)
        self.tau = tau
        self.verbose = verbose

        self.no_obs = np.unique(seq).shape[0]
        self.stim_ind = np.zeros((self.T, self.no_obs))

        # Construct matrix where col represents binary ind of specific stim at t
        for t in range(self.T):
            self.stim_ind[t, self.sequence[t]] = 1

        # AP: Generate T-dim vector indicating no-alternation from t-1 to t
        self.repetition = np.zeros(self.T)
        for t in range(1, self.T):
            if self.sequence[t] == self.sequence[t-1]:
                self.repetition[t] = 1

        # TP: Generate T-dim vectors indicating transition from state i
        self.transitions = np.zeros((self.T, self.no_obs))
        for t in range(1, self.T):
            self.transitions[t, 0] = (self.sequence[t-1] == 0)
            self.transitions[t, 1] = (self.sequence[t-1] == 1)
            self.transitions[t, 2] = (self.sequence[t-1] == 2)

        # Generate one T matrix with all discounting values
        self.exp_forgetting = np.exp(-self.tau*np.arange(self.T)[::-1])
    def init_hmm(self):
        """
        Input: number of desired hidden states for HMM model
        Output: Uniformly initialized matrices for HMM training
        """

        startprob = np.repeat(1./self.n_states, self.n_states)
        transmat = np.repeat([startprob], self.n_states, axis=0)
        temp = np.repeat(1./self.no_obs, self.no_obs)
        emissionprob = np.repeat([temp], self.n_states, axis=0)

        return startprob, transmat, emissionprob


    def update_posterior(self, type, get_ic=False):
        """
        Input: Unique state id transformed data, length per ep trace and HMM inits
        Output: The trained HMM model with all attributes
        - Option: If desired get AIC and BIC for model as well
        """
        startprob, transmat, emissionprob = self.init_hmm()
        # Uniform Initialization
        model = hmm.MultinomialHMM(n_components=self.n_states)
        model.startprob = startprob
        model.transmat = transmat
        model.emissionprob = emissionprob

        if type == "SP":
            temp = self.sequence[:self.t+1].reshape(1, -1).T
        elif type == "AP":
            temp = self.repetition[:self.t+1].reshape(1, -1).T

        self.model = model.fit(temp)

        if get_ic:
            logprob, posteriors = model.score_samples(self.sequence[:self.t+1])

            k = emissionprob.shape[1]
            p = n_states**2 + k*n_states - 1
            T = len(data_encoded)

            aic = -2*logprob + 2*p
            bic = -2*logprob + p*math.log(T)

            return aic, bic

    def posterior_predictive(self):
        return

    def naive_posterior(self, alphas):
        return self.posterior_predictive()/self.posterior_predictive().sum(axis=0)

    def predictive_surprisal(self, type, ind):
        return -np.log(self.posterior_predictive()[ind])

    def bayesian_surprisal(self, type, posterior_old):
        return kl_general(posterior_old, self.posterior_predictive())

    def corrected_surprisal(self, type, alphas):
        return kl_general(self.naive_posterior(), self.posterior_predictive())

    def compute_surprisal(self, type):
        print("{}: Computing different surprisal measures for all {} timesteps.".format(type, self.T))
        results = []

        if type == "SP":
            self.alphas = np.ones(self.no_obs)
        elif type == "AP":
            self.alphas = np.ones(2)
        elif type == "TP":
            self.alphas = np.ones((self.no_obs, self.no_obs))
        else:
            raise Exception, "Provide right model type (SP, AP, TP)"

        for t in range(self.T):
            # Loop over the full sequence and compute surprisal iteratively
            posterior_old = self.posterior.copy()
            self.t = t
            self.update_posterior(type)

            if type == "SP":
                ind = int(self.sequence[self.t])
            elif type == "AP":
                ind = int(self.repetition[self.t])
            elif type == "TP":
                # from and to stimulus transition
                ind = (np.argmax(self.transitions[self.t, :]), np.argmax(self.stim_ind[self.t, :]))
            else:
                raise Exception, "Provide right model type (SP, AP, TP)"

            PS_temp = self.predictive_surprisal(type, self.alphas, ind)
            BS_temp = self.bayesian_surprisal(type, alphas_old, self.alphas)
            CS_temp = self.corrected_surprisal(type, self.alphas)
            print(self.alphas)
            print(alphas_old)
            print(PS_temp, BS_temp, CS_temp)

            temp = [t, self.sequence[t], self.hidden[t], PS_temp, BS_temp, CS_temp]
            distr_params = list(self.alphas.reshape(1, -1)[0])
            results.append(temp + distr_params)
        print("{}: Done computing surprisal measures for all {} timesteps.".format(type, self.T))
        return np.asarray(results)


def main(seq, hidden, tau, model,
         prob_regime_init, prob_obs_init, prob_obs_change, prob_regime_change,
         save_results=False, title="temp", verbose=False):
    # II: Compute Surprisal for all time steps for Stimulus Prob CatDir Model
    CD_SBL_temp = SBL_Cat_Dir(seq, hidden, tau)
    results = CD_SBL_temp.compute_surprisal(model)

    time = results[:,0]
    sequence = results[:, 1]
    hidden = results[:, 2]
    PS = results[:, 2]
    BS = results[:, 3]
    CS = results[:, 4]

    results_formatted = {"time": time,
                         "sequence": sequence,
                         "hidden": hidden,
                         "predictive_surprise": PS,
                         "bayesian_surprise": BS,
                         "confidence_corrected_surprise": CS,
                         "prob_regime_init": prob_regime_init,
                         "prob_obs_init": prob_obs_init,
                         "prob_obs_change": prob_obs_change,
                         "prob_regime_change": prob_regime_change}

    if save_results:
        save_obj(results_formatted, results_dir + title)


def test_agent(seq, hidden, tau, model, verbose=False):
    # Test IIa: Initialize SBL (seq, forgetting param), update posterior (t=3)
    CD_SBL_temp = SBL_Cat_Dir(seq, hidden, tau=0.)
    CD_SBL_temp.update_posterior(2, model)
    CD_SBL_temp.t = 2
    print("{}: Dirichlet-Distribution after 2 timestep: alphas = {}".format(model, CD_SBL_temp.alphas))
    print("---------------------------------------------")

    # Test IIb: Compute Surprisal once (SP, t=3)
    print("{}: Predictive Surprisal at t=3: {}".format(model, CD_SBL_temp.predictive_surprisal()))
    print("{}: Bayesian Surprisal at t=3: {}".format(model, CD_SBL_temp.bayesian_surprisal()))
    print("{}: Confidence-Corrected Surprisal at t=3: {}".format(model, BB_SBL_temp.corrected_surprisal()))
    print("---------------------------------------------")

    # Test IIc: Compute Surprisal for all time steps for Stimulus Prob BB Model
    results = CD_SBL_temp.compute_surprisal(model)
    print("---------------------------------------------")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-file', '--sample_file', action="store",
                        default="temporary_sample_title", type=str,
                        help='Title of file in which sequence in stored')
    parser.add_argument('-tau', '--forget_param', action="store",
                        default=0., type=float,
                        help='Exponentially weighting parameter for memory/posterior updating')
    parser.add_argument('-model', '--model', action="store", default="SP",
                        type=str,
                        help='Categorical Dirichlet Probability Model (SP, AP, TP)')
    parser.add_argument('-pkl_in', '--pickle', action="store_true", help='Load matlab sequence file.')
    parser.add_argument('-T', '--test', action="store_true", help='Run tests.')
    parser.add_argument('-S', '--save', action="store_true", help='Save results to array.')
    parser.add_argument('-v', '--verbose',
                        action="store_true",
                        default=False,
						help='Get status printed out')

    args = parser.parse_args()

    if args.pickle:
        sample = load_obj(results_dir + args.sample_file + ".pkl", False)
    else:
        sample = load_obj(results_dir + args.sample_file + ".mat", True)

    seq = sample["sample_output"][:, 2]
    hidden = sample["sample_output"][:, 1]

    prob_regime_init = sample["prob_regime_init"]
    prob_obs_init = sample["prob_obs_init"]
    prob_obs_change = sample["prob_obs_change"]
    prob_regime_change = sample["prob_regime_change"]

    tau = args.forget_param
    model = args.model

    run_test = args.test
    save_results = args.save
    verbose = args.verbose

    if run_test:
        print("Started running basic tests.")
        test_agent(seq, hidden, tau, model, verbose)

    else:
        main(seq, hidden, tau, model,
             prob_regime_init, prob_obs_init, prob_obs_change,
             prob_regime_change,
             save_results, title="CD_" + model + "_" + args.sample_file,
             verbose=False)

    """
    How to run:
        pythonw seq_gen.py -t S1_800 -obs_change 0.75 0.15 0.85 0.25 0.5 0.75 0.25 0.5 -order 2 -matlab -seq 500
        pythonw sbl_cat_dir.py -file S1_800 -S -model SP
    """
